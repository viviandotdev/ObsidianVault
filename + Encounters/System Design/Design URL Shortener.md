---
created: 2023-09-01 14:41
modified: 2025-07-20T20:10:54-04:00
---
up:: [[01 System Design Problems]]
tags:: [[system-design]]

### Requirements
**URL shortening** is a service that takes long URLs and provides a shortened version to make them more manageable and easier to share.
**Functional Requirements**
- **URL Shortening**: Given a long URL, our service should generate a unique shorter version of it.
- **URL Redirection**: When a user accesses a short URL, our system should be able to redirect the user to the original URL.
- **URL Expiration**: URL links should expire after a standard default timespan

**Non-Functional Requirements**
**[[Availability]]**: The system should be reliable and available 99.99% of the time (availability > consistency)
	**why is [[availability]] more important for URL shortener?**
		- low availability creates a broken user experience, when the system is unavailable, users cannot be redirected and breaks every single link that uses the service
	**why [[consistency]] is not as important**?
		- low consistency means that newly created URL might not be immediately redirect-able from all servers simultaneously. A brief inconsistency where a new URL is not available on every node immediately is a minor inconvenience in comparison to every URL not working
		
**[[Scalability]]**: The system needs to be horizontally scalable to support 1B shortened URLs and 100M DAU
**Latency**: The redirection should occur with minimal delay (< 100ms)
**Security**: From a security standpoint, the short links generated by our
system should not be predictable.

### APIs
**URL shortening API** - Generates a short URL from a long URL
**Endpoint:** POST `/shorten_url`
**Parameters**
- `auth_token` (string, required): it is used to authenticate API requests.
- `long_url` (string, required): The long URL that needs to be shortened
**Responses**:
	**200:** Successful operation, the API returns the shortened URL as a string.

**URL redirecting API** - Redirect a short URL to the corresponding long URL
**Endpoint:** GET `/{short_url}`
**Parameters:**
- `auth_token` (string, required): it is used to authenticate API requests.
- `short_url` (string, required): the shortened URL
**Responses**:
- **302**: Returns HTTP redirect response and redirects the user to the long URL associated with the `short_url`
- **401:** Unauthorized error
- **404**: URL not found error

### Data Model
Given our URL shortening service's non-relational nature and need to handle significant data and traffic, NoSQL databases like MongoDB or Cassandra are ideal due to their seamless horizontal scalability.
In a URL shortener, the core entities are very straightforward:
**Original URL**: The original long URL that the user wants to shorten.
**Short URL**: The shortened URL that the user receives and can share.
**User**: Represents the user who created the shortened URL.

**Database Schema**
![[URL Shortener- Database Schema.svg]]
### Schema Code
```
// Use DBML to define your database structure
// Docs: https://dbml.dbdiagram.io/docs

Table URL {
hash varchar(16) [primary key]
long URL varchar
created_at timestamp
expired_at timestamp
user_id int
}
Table User {
user_id int [primary key]
name varchar
email varchar
created_at timestamp
}
Ref: URL.user_id > User.user_id // many-to-one
```
### System Components
[[Client]]- User interacts with the system through a web or mobile application
[[Load Balancer]]: We can include a [[load balancer]] between the client and the application servers. It will evenly distribute clients' requests among the application servers using a round-robin algorithm.
[[Database]]: As discussed above, we will use a [[NoSQL]] database due to the non-relational nature of our database schema. This database will be [[Database Sharding|sharded]], which means it is partitioned into multiple databases stored on different servers, eliminating single points of failure and enhancing system [[availability]] and [[fault tolerance]].
**[[cache|Cache]]**: To improve performance, we will use a cache that will allow us to access frequently accessed URLs quickly. For the [[cache]], we can use the [[LRU cache Algorithm]] (Least Recently Used) mechanism, which evicts the least recently used item in the cache to make room for new entries.
### Shortening the URL
How to generate a short unique key for a given URL.

**Hash Function**
Implement a hash function that hashes a long URL to a 7-character string. We can use well-known hash functions such as SHA-1 or MD5 to compute a unique hash of the given URL.

Use the SHA-256 hash function, it will produce a very long hash value
Take the output and encode using base62 encoding scheme (compact representation)
To shorten this, just take the first N characters as our short code. 
	However, this can lead to collisions. To resolve collisions, we can recursively append a predefined string until the collision is resolved.

![[URL Shortening]]
### Redirecting the URL
**Workflow**
1. The user clicks on a short URL link
2. The load balancers redirect the request to the available server.
3. **Case 1:** If the short URL is already in the cache, return the long URL.
	![[URL Redirecting-Case 1]]
4. **Case 2:** If the short URL is not in the cache, fetch the URL from the database.
	![[URL Redirecting-Case 2]]
5. **Case 3:** If the short URL does not exist in the database, unsuccessful redirection returns an error message.
	![[URL Redirecting-Case 3]]

**Two Main Types of HTTP Redirects**
**301 (Permanent Redirect):** This indicates that the resource has been permanently moved to the target URL. Browsers typically cache this response, meaning subsequent requests for the same short URL might go directly to the long URL, bypassing our server.

**302 (Temporary Redirect):** This suggests that the resource is temporarily located at a different URL. Browsers do not cache this response, ensuring that future requests for the short URL will always go through our server first.

For a URL shortener, a 302 redirect is often preferred because:
- It gives us more control over the redirection process, allowing us to update or expire links as needed.
- It prevents browsers from caching the redirect, which could cause issues if we need to change or delete the short URL in the future.
- It allows us to track click statistics for each short URL (even though this is out of scope for this design).

### Review the requirements
**Availability**: Most of our components such as databases, caches, and application servers will be replicated to ensure [[availability]] and fault tolerance. 
	One common replication strategy we can use is [[Master Slave Replication]]. 
		One database is the master, which is the main source of truth and holds all the original data that needs to be copied. 
		Any changes made to the master will be copied to the slave databases.  
		The slave replicas can also handle read operations, therefore improving overall system performance. 
		However, this can introduce consistency issues in our system due to the asynchronous nature of data replication between the master and slave databases.
**Scalability**: Horizontal [[Database Sharding|sharding]] of the database. 
- The distribution of data among the shards will be through [[consistent hashing]]. In addition, we will use a [[NoSQL]] database such as [[MongoDB]]. [[NoSQL]] databases which are not highly relational can be easily scaled horizontally because the data can be spread across multiple nodes.
**Latency**: 
- [[Caches]] reduce latency by storing frequently accessed URLs. Accessing data from our cache is much faster than accessing it from slower data sources such as our database
- Leveraging a [[CDN]] can also help reduce latency
**Security**: generating unique un-predictable short urls
	[[Hash function]], Due to the unpredictability of hash functions, users will not be able to guess the long URL from the short URL.

**Resources**
[ByteByteGo](https://bytebytego.com/courses/system-design-interview/design-a-url-shortener)
[Design Interview](https://www.hellointerview.com/learn/system-design/problem-breakdowns/bitly)