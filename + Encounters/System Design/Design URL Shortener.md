---
created: 2023-09-01 14:41
modified: 2025-07-20T20:10:54-04:00
---
up:: [[01 System Design Problems]]
tags:: [[system-design]]

### Requirements
**URL shortening** is a service that takes long URLs and provides a shortened version to make them more manageable and easier to share.
**Functional Requirements**
- **URL Shortening**: Given a long URL, our service should generate a unique shorter version of it.
- **URL Redirection**: When a user accesses a short URL, our system should be able to redirect the user to the original URL.
- **URL Expiration**: URL links should expire after a standard default timespan

**Non-Functional Requirements**
**[[Availability]]**: The system should be reliable and available 99.99% of the time (availability > consistency)
	**why is availability more important for URL shortener?**
		- low availability creates a broken user experience, when the system is unavailable, users cannot be redirected and breaks every single link that uses the service
	**why [[consistency]] is not as important**?
		- low consistency means that newly created URL might not be immediately redirect-able from all servers simultaneously. A brief inconsistency where a new URL is not available on every node immediately is a minor inconvenience in comparison to every URL not working
		
**[[Scalability]]**: The system needs to be horizontally scalable to support 1B shortened URLs and 100M DAU
**Latency**: The redirection should occur with minimal delay (< 100ms)
**Security**: From a security standpoint, the short links generated by our
system should not be predictable.

### APIs
**URL shortening API** - Generates a short URL from a long URL
**Endpoint:** POST `/shorten_url`
**Parameters**
- `auth_token` (string, required): it is used to authenticate API requests.
- `long_url` (string, required): The long URL that needs to be shortened
**Responses**:
	**200:** Successful operation, the API returns the shortened URL as a string.

**URL redirecting API** - Redirect a short URL to the corresponding long URL
**Endpoint:** GET `/{short_url}`
**Parameters:**
- `auth_token` (string, required): it is used to authenticate API requests.
- `short_url` (string, required): the shortened URL
**Responses**:
- **302**: Returns HTTP redirect response and redirects the user to the long URL associated with the `short_url`
- **401:** Unauthorized error
- **404**: URL not found error

### Data Model
Given our URL shortening service's non-relational nature and need to handle significant data and traffic, NoSQL databases like MongoDB or Cassandra are ideal due to their seamless horizontal scalability.
In a URL shortener, the core entities are very straightforward:
**Original URL**: The original long URL that the user wants to shorten.
**Short URL**: The shortened URL that the user receives and can share.
**User**: Represents the user who created the shortened URL.

**Database Schema**
![[URL Shortener- Database Schema.svg]]
### Schema Code
```
// Use DBML to define your database structure
// Docs: https://dbml.dbdiagram.io/docs

Table URL {
hash varchar(16) [primary key]
long URL varchar
created_at timestamp
expired_at timestamp
user_id int
}
Table User {
user_id int [primary key]
name varchar
email varchar
created_at timestamp
}
Ref: URL.user_id > User.user_id // many-to-one
```
### System Components
[[Load Balancer]]: We can include a [[load balancer]] between the client and the application servers. It will evenly distribute clients' requests among the application servers using a round-robin algorithm.
[[Database Sharding]]: As discussed above, we will use a [[NoSQL]] database due to the non-relational nature of our database schema. This database will be sharded, which means it is partitioned into multiple databases stored on different servers, eliminating single points of failure and enhancing system availability and fault tolerance.
**Cache**: To improve performance, we will use a cache that will allow us to access frequently accessed URLs quickly. For the [[cache]], we can use the [[LRU cache Algorithm]] (Least Recently Used) mechanism, which evicts the least recently used item in the cache to make room for new entries.
### Shortening the URL
How to generate a short unique key for a given URL.

**Hash Function**
Implement a hash function that hashes a long URL to a 7-character string. We can use well-known hash functions such as SHA-1 or MD5 to compute a unique hash of the given URL.

If we use the MD5 hash function, it will produce a very long hash value (128 bits). In Hexadecimal, the hash value will still be 32 characters long.
To shorten this, just take the first 7 characters of the resulting hash value. However, this can lead to collisions. To resolve collisions, we can recursively append a predefined string until the collision is resolved.

![[URL Shortening]]
### Redirecting the URL
**Workflow**
1. The user clicks on a short URL link
2. The load balancers redirect the request to the available server.
3. **Case 1:** If the short URL is already in the cache, return the long URL.
	![[URL Redirecting-Case 1]]
4. **Case 2:** If the short URL is not in the cache, fetch the URL from the database.
	![[URL Redirecting-Case 2]]
5. **Case 3:** If the short URL does not exist in the database, unsuccessful redirection returns an error message.
	![[URL Redirecting-Case 3]]

### Review the requirements
**Availability**: Most of our components such as databases, caches, and application servers will be replicated to ensure availability and fault tolerance. One common replication strategy we can use is [[Master Slave Replication]]. With [[Master Slave Replication]], one database is the master, which is the main source of truth and holds all the original data that needs to be copied. Any changes made to the master will be copied to the slave databases.  The slave replicas can also handle read operations, therefore improving overall system performance. However, this can introduce consistency issues in our system due to the asynchronous nature of data replication between the master and slave databases.
**Scalability**: Horizontal [[Database Sharding|sharding]]  of the database. The distribution of data among the shards will be through [[consistent hashing]]. In addition, we will use a [[NoSQL]] database such as MongoDB. [[NoSQL]] databases which are not highly relational can be easily scaled horizontally because the data can be spread across multiple nodes.
**Latency**: [[Caches]] reduce latency by storing frequently accessed URLs. Accessing data from our cache is much faster than accessing it from slower data sources such as our database. Leveraging a [[CDN]] can help reduce latency
**Security**: Our system is secure because it uses hash functions, which are designed to be deterministic. This means that although the same input will always generate the same hash value, it is practically impossible to obtain the original input from its hash value. Due to the unpredictability of hash functions, users will not be able to guess the long URL from the short URL.


[ByteByteGo](https://bytebytego.com/courses/system-design-interview/design-a-url-shortener)
[Design Interview](https://www.hellointerview.com/learn/system-design/problem-breakdowns/bitly)